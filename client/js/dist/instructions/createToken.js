/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getAddressEncoder, getBytesDecoder, getBytesEncoder, getProgramDerivedAddress, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from "@solana/kit";
import { PUMP_PROGRAM_ADDRESS } from "../programs";
import { expectAddress, getAccountMetaFactory, } from "../shared";
export const CREATE_TOKEN_DISCRIMINATOR = new Uint8Array([
    84, 52, 204, 228, 24, 140, 234, 75,
]);
export function getCreateTokenDiscriminatorBytes() {
    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_DISCRIMINATOR);
}
export function getCreateTokenInstructionDataEncoder() {
    return transformEncoder(getStructEncoder([
        ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
        ["solReserve", getU64Encoder()],
        ["tokenReserve", getU64Encoder()],
        ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
        ["ticker", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
        ["uri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ]), (value) => (Object.assign(Object.assign({}, value), { discriminator: CREATE_TOKEN_DISCRIMINATOR })));
}
export function getCreateTokenInstructionDataDecoder() {
    return getStructDecoder([
        ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
        ["solReserve", getU64Decoder()],
        ["tokenReserve", getU64Decoder()],
        ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
        ["ticker", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
        ["uri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ]);
}
export function getCreateTokenInstructionDataCodec() {
    return combineCodec(getCreateTokenInstructionDataEncoder(), getCreateTokenInstructionDataDecoder());
}
export async function getCreateTokenInstructionAsync(input, config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    // Program address.
    const programAddress = (_a = config === null || config === void 0 ? void 0 : config.programAddress) !== null && _a !== void 0 ? _a : PUMP_PROGRAM_ADDRESS;
    // Original accounts.
    const originalAccounts = {
        signer: { value: (_b = input.signer) !== null && _b !== void 0 ? _b : null, isWritable: true },
        globalState: { value: (_c = input.globalState) !== null && _c !== void 0 ? _c : null, isWritable: false },
        bondingCurve: { value: (_d = input.bondingCurve) !== null && _d !== void 0 ? _d : null, isWritable: true },
        mint: { value: (_e = input.mint) !== null && _e !== void 0 ? _e : null, isWritable: true },
        bondingCurveAta: { value: (_f = input.bondingCurveAta) !== null && _f !== void 0 ? _f : null, isWritable: true },
        tokenProgram: { value: (_g = input.tokenProgram) !== null && _g !== void 0 ? _g : null, isWritable: false },
        systemProgram: { value: (_h = input.systemProgram) !== null && _h !== void 0 ? _h : null, isWritable: false },
        rent: { value: (_j = input.rent) !== null && _j !== void 0 ? _j : null, isWritable: false },
        associatedTokenProgram: {
            value: (_k = input.associatedTokenProgram) !== null && _k !== void 0 ? _k : null,
            isWritable: false,
        },
        tokenMetadataProgram: {
            value: (_l = input.tokenMetadataProgram) !== null && _l !== void 0 ? _l : null,
            isWritable: false,
        },
        metadata: { value: (_m = input.metadata) !== null && _m !== void 0 ? _m : null, isWritable: true },
    };
    const accounts = originalAccounts;
    // Original args.
    const args = Object.assign({}, input);
    // Resolve default values.
    if (!accounts.bondingCurve.value) {
        accounts.bondingCurve.value = await getProgramDerivedAddress({
            programAddress,
            seeds: [
                getBytesEncoder().encode(new Uint8Array([66, 79, 78, 68, 73, 78, 71, 95, 83, 69, 69, 68])),
                getAddressEncoder().encode(expectAddress(accounts.mint.value)),
            ],
        });
    }
    if (!accounts.bondingCurveAta.value) {
        accounts.bondingCurveAta.value = await getProgramDerivedAddress({
            programAddress: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
            seeds: [
                getAddressEncoder().encode(expectAddress(accounts.bondingCurve.value)),
                getBytesEncoder().encode(new Uint8Array([
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70, 206, 235,
                    121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58, 140, 245, 133,
                    126, 255, 0, 169,
                ])),
                getAddressEncoder().encode(expectAddress(accounts.mint.value)),
            ],
        });
    }
    if (!accounts.tokenProgram.value) {
        accounts.tokenProgram.value =
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
    }
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            "11111111111111111111111111111111";
    }
    if (!accounts.rent.value) {
        accounts.rent.value =
            "SysvarRent111111111111111111111111111111111";
    }
    if (!accounts.associatedTokenProgram.value) {
        accounts.associatedTokenProgram.value =
            "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
    }
    if (!accounts.tokenMetadataProgram.value) {
        accounts.tokenMetadataProgram.value =
            "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
    }
    const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
    const instruction = {
        accounts: [
            getAccountMeta(accounts.signer),
            getAccountMeta(accounts.globalState),
            getAccountMeta(accounts.bondingCurve),
            getAccountMeta(accounts.mint),
            getAccountMeta(accounts.bondingCurveAta),
            getAccountMeta(accounts.tokenProgram),
            getAccountMeta(accounts.systemProgram),
            getAccountMeta(accounts.rent),
            getAccountMeta(accounts.associatedTokenProgram),
            getAccountMeta(accounts.tokenMetadataProgram),
            getAccountMeta(accounts.metadata),
        ],
        programAddress,
        data: getCreateTokenInstructionDataEncoder().encode(args),
    };
    return instruction;
}
export function getCreateTokenInstruction(input, config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    // Program address.
    const programAddress = (_a = config === null || config === void 0 ? void 0 : config.programAddress) !== null && _a !== void 0 ? _a : PUMP_PROGRAM_ADDRESS;
    // Original accounts.
    const originalAccounts = {
        signer: { value: (_b = input.signer) !== null && _b !== void 0 ? _b : null, isWritable: true },
        globalState: { value: (_c = input.globalState) !== null && _c !== void 0 ? _c : null, isWritable: false },
        bondingCurve: { value: (_d = input.bondingCurve) !== null && _d !== void 0 ? _d : null, isWritable: true },
        mint: { value: (_e = input.mint) !== null && _e !== void 0 ? _e : null, isWritable: true },
        bondingCurveAta: { value: (_f = input.bondingCurveAta) !== null && _f !== void 0 ? _f : null, isWritable: true },
        tokenProgram: { value: (_g = input.tokenProgram) !== null && _g !== void 0 ? _g : null, isWritable: false },
        systemProgram: { value: (_h = input.systemProgram) !== null && _h !== void 0 ? _h : null, isWritable: false },
        rent: { value: (_j = input.rent) !== null && _j !== void 0 ? _j : null, isWritable: false },
        associatedTokenProgram: {
            value: (_k = input.associatedTokenProgram) !== null && _k !== void 0 ? _k : null,
            isWritable: false,
        },
        tokenMetadataProgram: {
            value: (_l = input.tokenMetadataProgram) !== null && _l !== void 0 ? _l : null,
            isWritable: false,
        },
        metadata: { value: (_m = input.metadata) !== null && _m !== void 0 ? _m : null, isWritable: true },
    };
    const accounts = originalAccounts;
    // Original args.
    const args = Object.assign({}, input);
    // Resolve default values.
    if (!accounts.tokenProgram.value) {
        accounts.tokenProgram.value =
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
    }
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            "11111111111111111111111111111111";
    }
    if (!accounts.rent.value) {
        accounts.rent.value =
            "SysvarRent111111111111111111111111111111111";
    }
    if (!accounts.associatedTokenProgram.value) {
        accounts.associatedTokenProgram.value =
            "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
    }
    if (!accounts.tokenMetadataProgram.value) {
        accounts.tokenMetadataProgram.value =
            "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
    }
    const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
    const instruction = {
        accounts: [
            getAccountMeta(accounts.signer),
            getAccountMeta(accounts.globalState),
            getAccountMeta(accounts.bondingCurve),
            getAccountMeta(accounts.mint),
            getAccountMeta(accounts.bondingCurveAta),
            getAccountMeta(accounts.tokenProgram),
            getAccountMeta(accounts.systemProgram),
            getAccountMeta(accounts.rent),
            getAccountMeta(accounts.associatedTokenProgram),
            getAccountMeta(accounts.tokenMetadataProgram),
            getAccountMeta(accounts.metadata),
        ],
        programAddress,
        data: getCreateTokenInstructionDataEncoder().encode(args),
    };
    return instruction;
}
export function parseCreateTokenInstruction(instruction) {
    if (instruction.accounts.length < 11) {
        // TODO: Coded error.
        throw new Error("Not enough accounts");
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = instruction.accounts[accountIndex];
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            signer: getNextAccount(),
            globalState: getNextAccount(),
            bondingCurve: getNextAccount(),
            mint: getNextAccount(),
            bondingCurveAta: getNextAccount(),
            tokenProgram: getNextAccount(),
            systemProgram: getNextAccount(),
            rent: getNextAccount(),
            associatedTokenProgram: getNextAccount(),
            tokenMetadataProgram: getNextAccount(),
            metadata: getNextAccount(),
        },
        data: getCreateTokenInstructionDataDecoder().decode(instruction.data),
    };
}
